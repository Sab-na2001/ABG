= Documentation

Our goal was to create the interface of the checkers game. The user can access the game from the menu by clicking the Play button of the checkers game. 

After pressing this button, it will redirect the user to the selected game. He can start a new game or continue an existing one by using his https://en.wikipedia.org/wiki/Portable_Draughts_Notation[Portable Draughts Notaton] (PDN). 
We also made sure to respect a similar layout to the chess game in terms of colors and available buttons. The goal is to have a coherent environment through the different games. 

The interface of the checkers game was made using HTML, CSS, Javascript. 

It is interesting to know that it is not possible to load a game if no PDN has been entered.  
There is now a "Quit" button to return to the Main Menu.
We also display in real time the player who has to play (Black or White). 
There is also a move suggestion useful for the novices to know the possible moves of a piece in the game

Screenshot 1:

image::Image/interface_quit.png[]

See: https://github.com/oliviercailloux/Assisted-Board-Games/blob/master/Doc/TODO.adoc[TODO’s].

=== Play Chess Diagram:
Complete use case diagram is: https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/ABG-2/Doc/Images/PlayerPlaysGame.SVG[here].

The use case diagram https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/ABG-2/Doc/Diagrams/Play_chess.SVG[Play chess] contains two use cases `Play chess` and `Play new chess game` and an actor: the player. This use case will be our main focus at first, meaning that we will need to have a server to record the moves previously played.

=== Record Chess Move Graphically Diagram:

Complete Use Case Diagram: https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/ABG-3-Amine/Doc/Diagrams/Record_chess_move_graphically.SVG[here]

The use case diagram Record Chess Move Graphically contains 2 actors, the player and the server. This Use Case describe the movement of a piece by the player.
When the player select a chess piece, it will display all the possible moves. Then, the player can change the piece position.
After the play, the recording of the new position by the server will be done. The server can also recover the moves.
This Use Case needs to be created first to be connected by the Use Case 1

=== Record Chess Move Diagram:

Complete Use Case Diagram: https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/ABG-4-Final/Doc/Diagrams/Record_Chess_Move.SVG[here].

The Use Case Diagram Record Chess Move contains the two same actors mentioned above, linked to a Use Case Record Chess Move.
In this situation, the player have to play before the system records the chess move. After the system recorded the movement, it will update the position and recover the updates from the opposite player. We didn't add all the details in the Use Case Diagram because it was too heavy.
This Use Case will be our short term main focus.

== Original description (to be translated)
Based on an idea generously provided by Vincent Giroux (thanks to him!)

The https://boardgamegeek.com/image/1648160/game-thrones-board-game-second-edition [board] https://boardgamegeek.com/wiki/page/Welcome_to_BoardGameGeek [game] essentially comes in two versions: on site, without a computer; or https://www.yucata.de/en [purely] https://fr.boardgamearena.com/ [online]. In the first case, people gather and play around a board and physically embodied game elements. In the second case, people usually play at home.

The Assisted Board Game concept proposes to combine the advantages of both aspects. (For its detractors: the disadvantages of both aspects.) It is about sharing a moment together, being physically together, but with the help of a computer implementation. This will be particularly welcome for games requiring a https://boardgamegeek.com/image/2836495/republic-rome [lot] of manipulation of pieces and adjustments without decisions, or a https://boardgamegeek.com/image/1822915/zombie-15 [long] set-up, but also to save the game, to replay an existing game, or to be assisted in various ways by a computer.

An Assisted Board Game is ideally composed of https://novotelstore.com/fr/table-interactive-play#prettyPhoto[media_gallery]/1/ [an] https://www.theguardian.com/games/2018/mar/14/playtable-tablet-blockchain-technology-enhance-board-games-blokparty [interactive] https://d2rormqr1qwzpz.cloudfront.net/photos/2012/03/16/55-32402-11672_pax_catan_3_super.jpg [table], which acts as the game board, and one tablet per player. (For this project we will be satisfied with one computer acting as the interactive table and one computer per player).

The aim of this project is to build a generic system that can easily implement a wide range of games. We will start from an existing https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/ABG-DocTranslate/Doc/README.adoc [project], which has implemented a system for playing chess. The aim will be to extend the functionalities to improve this chess game, but above all to generalise the logic to allow the inclusion of other games, initially similar (checkers...) then more distinct (poker...). The system will only allow the generation of the game engine, the ambition does not extend to the automatic generation of the graphical interface which will have to be programmed manually for each game.

The existing project allows to display the chess board; to play a move; to count the remaining time; it integrates a logic of saving and restoring a game and recovering a historical game, puzzles...

== Original documentation (to be translated)
For now, the program launches a server. When browsing to http://localhost:8080, the Javascript interface get activated.

Since we didn’t bring the whole code into quarkus branch, the following part is not functional yet but will be later.

[The interface works by communicating with the server in question. When it receives a request at the address http://localhost:8080/api/v1/game/…, the server calls a method of the GameResource class (because it is annotated @Path("api/v1/game")). The method called depends on the continuation of the requested address. For example, a request to the address api/v1/game/new calls the createGame() method (because this method is annotated @Path("new")). These methods usually call an EntityManager (part of a Java standard, Java Persistence API) that places objects in the server database or retrieves them from it.

When a request is sent to api/v1/game/import, the method importGame(GameDAO) is called. The request is supposed to contain data in JSON format, that are automatically transformed by the server into a GameDAO type object and then passed as a parameter to the method.]

== References
* https://dominion.games/
* https://boardgamearena.com/
* https://simmer.io/upload
* http://www.vassalengine.org/ : « Once we've released 3.3.0, I'll be focusing my efforts on assembling and updating all of that so we can get moving on V4. », http://www.vassalengine.org/forum/viewtopic.php?f=5&t=10027#p58941[29 mars 2020] http://www.vassalengine.org/forum/viewtopic.php?f=5&t=11195[Test builds for 3.3.0]. http://www.vassalengine.org/forum/viewtopic.php?f=5&t=3914[Roadmap for VASSAL 4] (2011) (The post about protobuf could be of interest.)
* https://chess.stackexchange.com/a/33584[Visual chess moves]
* https://github.com/tdf/odftoolkit/raw/master/src/site/site/content/odftoolkit_website/docs/presentations/2019%20-%20ACM%20DocEng%20-%20The_Next_Millennium_Document_Format_DRAFT_20190712.pdf, Svante Schubert. We should exchange patches (Operational Transformations, OT) and view a document as a list of changes, or a tree of changes. We should allow for more efficient standardization by means of supporting software tools.


