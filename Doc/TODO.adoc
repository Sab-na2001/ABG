= TODO

* * Les clients individuels des joueurs leur permettront de jouer en recevant l’assistance d’un ordinateur : le joueur peut de façon privée (sans le montrer à son adversaire) proposer un coup, et l’ordinateur lui montrera les meilleurs réponses à son coup. En limitant adéquatement la profondeur de recherche de l’ordinateur, cela pourrait permettre aux joueurs d’éviter les erreurs basiques, ou fournir un avantage compensatoire à un joueur plus faible, ou aider à l’apprentissage. (Pour commencer on choisira n’importe quelle façon simple de trouver des coups valables, à terme il serait bon d’utiliser une bibliothèque existante de recherche de bons coups)
* Autres aides : liste de bons coups possibles pour le prochain coup, stratégie menant à la victoire ou à une meilleure position (sous forme de meilleurs coups de part et d’autre), stratégie sous forme d’arbre de profondeur et largeur donnés.
* Séparer ce qui est propre au jeu d’échec (en gros, dans le package `io.github.oliviercailloux.assisted_board_games.model`) de la partie serveur (en gros, le reste), en vue de la généralisation à d’autres jeux. Envisager de fournir à `GameResources` une interface qui offre les services spécifiques au jeu pour lequel un serveur est demandé.
* Généraliser autant que possible pour faciliter l’implémentation d’un nouveau jeu (tel que les dames). Par exemple, la logique de comptage du temps n’est pas spécifique aux échecs et devrait pouvoir être réutilisée.
* Implémenter un nouveau jeu dans un autre sous-package (par exemple `checkers`). Ceci ne devrait pas induire de redondance avec le jeu existant.
* Prévoir une interface rudimentaire et générique pour ce nouveau jeu, sous forme d’affichage de l’état de la partie en JSON et envoi des nouveaux coups en JSON (donc sans graphisme)
* En plus de l’interface générique rudimentaire, envisager une interface spécifique au jeu de dames (similaire à celle utilisée pour les échecs)
* Implémenter un jeu (t.q. pierre, feuille, ciseaux) avec concept d’état partiellement caché : état complet (inclut données pour tous les joueurs, par ex. : joueur 1 a choisi _pierre_, joueur 2 n’a pas encore choisi) ; état partiel, visible par un joueur donné (par ex., le joueur 2 voit : joueur 1 a choisi, joueur 2 doit encore choisir) ; état visible, sous-ensemble des données visibles par tous (ce que voit un spectateur qui ne connait pas l’information propre aux joueurs). Dans le cas où tout est visible (par ex. les échecs), les trois états sont égaux.
* Implémenter un jeu (t.q. jeu de l’oie) avec hasard : l’état complet inclut un générateur déterministe qui contient toutes les possibilités, auquel on demande tout tirage aléatoire. Ce générateur doit être enregistré avec la partie, et n’est pas visible.
* Implémenter un jeu (t.q. Texas Hold’em) avec état partiellement caché et hasard.

== Autres idées
* Permettre un fork de partie à un certain coup (bonus : permettre d’enregistrer une série de générateurs avec une partie, associés à un numéro de coup, pour permettre de changer le générateur lors du fork) ; de nommer la partie (exemple : partie célèbre Kasparov contre Deep Blue), de trouver les états communs…
* Analyser le langages de description de http://www.zillions-of-games.com/[Zillion of Games] ou d’autres aspects de ce service et rédiger un rapport en Asciidoctor indiquant ce qui peut être utilisé dans le projet.
